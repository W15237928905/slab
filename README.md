# 1.题目： proj123-linux-slab-cpp

> 题目：Linux内核lab内存分配器对象化实现  
> 
> 内容：为了解决小块内存的分配，Linux内核基于Solaris 2.4中的slab分配算法实现了自己的slab分配器。除此之外，slab分配器另一个主要功能是作为一个高速缓存，它用来存储内核中那些经常分配并释放的对象。C + +语言提供了面向对象的语言层面支持，使对象的管理更为清晰。本项目拟利用C + +语言对Linux内核slab分配算法进行重新改写，实现面向对象的块内存分配与管理。

# 2.比赛准备

理论学习：

[Linux内存管理中的slab分配器 - 摩斯电码 - 博客园](https://www.cnblogs.com/pengdonglin137/p/3878552.html)

[slab分配器](https://github.com/sonntex/slab-allocator)

源码研读：

[Linux 内核 slab 分配器源码](https://zhuanlan.zhihu.com/p/358891862)

# 3.设计思路

### 1. 总体设计

代码实现了一个基于Linux内核Slab分配器的面向对象内存分配系统。设计遵循模块化和面向对象的原则，将内存分配器划分为多个组件，每个组件负责特定的功能。

### 2. 核心组件

- **kmem_cache_t**: 表示一个缓存，用于管理特定大小对象的内存分配。
- **slab**: 表示一个内存块，包含多个对象以及它们的分配状态。
- **buddy**: 表示伙伴系统，用于管理大块内存的分配和回收。
- **page**: 表示内存页，与slab关联，记录对象的分配信息。

### 3. 功能实现

- **初始化**: `kmem_init` 函数初始化整个内存分配系统，包括伙伴系统和缓存。
- **创建缓存**: `kmem_cache_create` 创建一个新的缓存，用于特定大小对象的管理。
- **内存分配**: `kmem_cache_alloc` 从指定缓存中分配内存。
- **内存释放**: `kmem_cache_free` 将内存返回给缓存。
- **缓存销毁**: `kmem_cache_destroy` 销毁一个不再需要的缓存。
- **内存分配器使用示例**: `example_usage` 演示了如何使用内存分配器。

### 4. 线程安全

- 使用 `recursive_mutex` 保证对缓存操作的线程安全。

### 5. 错误处理

- 通过 `log_error` 函数记录错误信息。
- `kmem_error_t` 枚举类型定义了可能的错误代码。

### 6. 性能优化

- **缓存着色**: 通过 `colour` 和 `colour_next` 减少缓存行冲突。

### 7. 内存管理策略

- **Slab列表**: 缓存包含完全空闲、部分空闲和已满的Slab列表。
- **内存回收**: `kmem_cache_shrink` 函数回收不再需要的内存页。

## 2.重点设计

> 对异常和错误使用结构体 `error` 来封装处理

1. **集中式错误管理**：通过结构体 `error` 封装错误信息，可以集中管理错误，而不是在代码的多个地方分散处理。这种方式使得错误处理逻辑更加清晰，易于维护和更新。

2. **增强的错误识别**：结构体 `error` 将错误提示信息更加完全，有助于用户或开发人员更快地识别和解决问题。

3. **提高代码的封装性**：使用结构体 `error` 封装错误处理逻辑，使得系统的各个组件更加独立，降低了它们之间的耦合度。每个组件都可以实现自己的错误处理机制，而不影响其他组件。

# 3.问题及解决方法

    在本次项目过程中我们使用的是最基础的dev-c++进行编译。而使用此编译器进行编译时会出现无法成功编译的报错信息，提示出现：#error This file requires compiler and library support for the ISO C++ 2011。我们需要在其工具里找到编译选项，在编译时加入以下命令-std=c++11，成功运行。在编译时出现not defined method问题，经过检查，发现有自创的库文件未导入。
