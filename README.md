# 1.题目：Linux内核lab内存分配器对象化实现  

### 说明 
-  赛题：`proj123-linux-slab-cpp`

-  队名：'希望队'

-  参赛成员：胡梅山 郭宇恒

> ### 简介
>  为了解决小块内存的分配，Linux内核基于Solaris 2.4中的slab分配算法实现了自己的slab分配器。
>
>  slab分配器另一个主要功能是作为一个高速缓存，它用来存储内核中那些经常分配并释放的对象。
>
>  C + +语言提供了面向对象的语言层面支持，使对象的管理更为清晰。
>
>  本项目拟利用C + +语言对Linux内核slab分配算法进行重新改写，实现面向对象的块内存分配与管理。
>
# 2.比赛准备

>理论学习：
>
>  [Linux内存管理中的slab分配器 - 摩斯电码 - 博客园](https://www.cnblogs.com/pengdonglin137/p/3878552.html)
>
>  [slab分配器](https://github.com/sonntex/slab-allocator)
>
>代码参考：
>
>  [Linux 内核 slab 分配器源码](https://zhuanlan.zhihu.com/p/358891862)
>
>  [MemoryAllocator 分配器](https://github.com/cpt95/MemoryAllocator/blob/master/OS2%20Allocator%20Project/)
>
# 3.设计思路

## 3.1. 总体设计

>  本项目实现实现了一个基于Linux内核Slab分配器的面向对象内存分配系统。
>  设计遵循模块化和面向对象的原则，将内存分配器划分为多个组件，每个组件负责特定内存分配不同阶段的功能。
>
## 3.2. 核心组件

 ### 3.2.1 头文件
>
>- **buddy**: 包含了实现Buddy内存分配器所需的所有声明和函数原型。
>- **error**: 包含与错误处理相关的所有声明和定义。
>- **list**: 包含用于实现链表数据结构的声明和定义。
>- **macros**: 包含与内存管理相关的宏定义。
>- **page**: 包含与页内存管理相关的声明和定义。
>- **slab**: 包含与Slab分配器相关的所有声明和函数原型。
>- **slabstruct**: 包含用于Slab分配器的数据结构定义。
>- **test**: 包含用于测试内存管理系统的声明和定义。
>
 ### 3.2.2 源文件
>
>- **buddy**: 实现Buddy内存分配算法。
>- **error**: 实现错误处理机制。
>- **main**: 主程序，调用各个模块并测试。
>- **page**: 实现页内存管理。
>- **slab**: 实现Slab内存分配器。
>- **slabstruct**: 定义和实现与Slab分配器相关的数据结构。
>- **test**: 实现测试内存管理系统。
>
## 3.3 功能实现
>
>  为实现slab内核分配算法面向对象的块内存分配管理，将代码分为五个部分。
>
>  一、bubby伙伴系统部分
>
>  该部分实现一基于伙伴系统的内存管理器。该系统用于动态分配和释放内存块，确保内存空间的高效利用和最小的碎片化。
>  
>- **初始化**: `buddy::buddy` 函数初始化伙伴系统，功能包含计算需要的额外空间，初始化内存管理的数据结构，分配和初始化页面及可用块链表。
>- **内存分配**: `kmem_getpages` 函数分配指定大小的内存块，功能包含检查请求的阶数是否合法，尝试找到合适的可用块，分割较大的块以满足请求以及返回分配的内存地  >址。
>- **内存释放**: `kmem_freepages` 函数释放指定大小的内存块，功能包含检查输入参数是否合法，合并相邻的伙伴块，将释放的块加入到可用列表中。
>
>  二、slab部分
>
>  该部分通过使用伙伴系统分配器和SLAB分配器相结合的方法，管理内存的分配和释放。
>
>- **初始化**: `kmem_init` 函数 初始化内存分配器，创建缓存。
>- **创建缓存**: `kmem_cache_create` 创建一个新的缓存，用于特定大小对象的管理。
>- **释放缓存**: `kmem_cache_shrink` 释放缓存中所有空闲的slab，返回释放的总块数的指数（2的幂次）。
>- **内存分配**: `kmalloc` 根据请求的大小选择合适的缓存，并从缓存中分配内存。
>               `kmem_cache_alloc` 从指定缓存中分配内存。
>- **内存释放**: `kmem_cache_free` 释放缓存中的内存。
>- **缓存销毁**: `kmem_cache_destroy` 销毁一个不再需要的缓存。
>
>  三、error部分
>
>  该部分用于输出程序错误信息，包含存储错误信息的结构体。
>
>- **初始化**: `init_error` 函数初始化error_t结构体，将错误状态设置为未发生，并初始化错误信息和函数名称。
>- **设置错误信息**: `set_error` 函数用于设置错误信息。
>- **打印错误信息**: `print_error` 函数用于打印错误信息。
>
>  四、page部分
>
>  该部分用于内存管理系统中的伙伴系统和Slab分配器，实现了一个页面的结构体及其相关操作
>- **初始化**: `init_page` 初始化页面对象，将页面对象的链表节点初始化，并将页面的阶数设置为未分配状态。
>- **设置缓存**: `set_cache` 设置页面对象所属的缓存对象。
>- **获取缓存**: `get_cache` 函数用于获取页面对象所属的缓存对象。
>- **设置slab对象**: `set_slab` 函数用于设置页面对象所属的slab对象。
>- **获取slab**: `get_slab` 函数用于获取页面对象所属的slab对象。
>- **虚实转换**: `virtual_to_page` 函数用于将虚拟地址转换为页面对象的指针。
>
>  五、main函数部分
>
>  该部分实现了一个基于SLAB分配器的内存管理系统，并通过多线程来测试内存分配和释放的功能。
>  使用宏定义了常量，用于指定内存块的数量、线程数量、迭代次数和共享对象的大小。
>  使用 objects_s 结构体用于存储缓存对象和数据指针。
>- **初始化**: 'construct' 初始化共享对象的数据。
>- **检查**: 'check' 检查数据是否被正确初始化。
>- **线程实现**: 'work' 为每个线程创建一个缓存，分配和检查对象，并最终释放所有分配的内存。
>- **运行线程**: 'run_threads' 用于运行多个线程。
>
## 3.4 安全
>- 线程安全
>- 使用 `recursive_mutex` 保证对缓存操作的线程安全。
>
## 3.5 性能优化
>
>- **缓存着色**: 通过 `colour` 和 `colour_next` 减少缓存行冲突。
>
## 3.6 内存管理策略
>
>- **Slab列表**: 缓存包含完全空闲、部分空闲和已满的Slab列表。
>- **内存回收**: `kmem_cache_shrink` 函数回收不再需要的内存页。
>
# 4.创新点
>
> 对异常和错误使用结构体 `error` 来封装处理
>
>- **集中式错误管理**：通过结构体 `error` 封装错误信息，可以集中管理错误，而不是在代码的多个地方分散处理。这种方式使得错误处理逻辑更加清晰，易于维护和更新。例 >如，当系统中某个组件发生错误时，错误信息会统一存储在 error 结构体中，开发人员只需查看该结构体对应的错误信息即可了解错误类型及错误位置。
>
>- **增强的错误识别**：结构体 `error` 将错误提示信息更加完全，有助于用户或开发人员更快地识别和解决问题。
>
>- **提高代码的封装性**：使用结构体 `error` 封装错误处理逻辑，使得系统的各个组件更加独立，降低了它们之间的耦合度。每个组件都可以实现自己的错误处理机制，而不影 >响其他组件。
>
>  通过引入 error 结构体来封装和处理错误信息，代码在错误管理方面具有显著的创新性。这不仅提高了代码的可读性和可维护性，还增强了系统的稳定性和可靠性，使得开发和维护过程更加高效。

# 5.总结

> 在本次项目设计初始阶段使用的是最基础的dev-c++进行编译。而使用此编译器进行编译时会出现无法成功编译的报错信息，提示出现：#error This file requires >compiler and library support for the ISO C++ 2011。
> 我们需要在其工具里找到编译选项，在编译时加入以下命令-std=c++11，而后成功运行。
>在编译时出现not defined method问题，经过检查，发现有自创的库文件未导入。导入创建的库文件后，程序成功运行。
>在分配内存至块时出现错误索引超出边界，通过修改error类中的message数组大小至50，既满足错误信息显示，同时程序成功运行。
>在调试程序过程中出现了各种问题，通过书写程序调试语句输出控制台，寻找Debug以及程序断点，调试修改程序。
>但此程序仍有缺陷，如样本数较少，无法判断是否适用于不同程序开发环境，错误种类较少，无法显示输出所有程序运行错误信息。程序不能实时更新错误种类，若出现不在error类中枚举的错误类型，程序显示错误，但无法定位错误位置。不能根据程序测试员的需求自主修改内存分配等。

>经过此次项目的研发测试，我们对操作系统中的伙伴系统以及slab分配算法有了更深刻的理解，对操作系统如何分配内存有了更加清晰地认识。
